// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
"use strict";
var fs = require("fs");
var Q = require('q');
var httpm = require('./HttpClient');
var serm = require('./Serialization');
var RestClient = (function () {
    function RestClient(userAgent, handlers, socketTimeout, versionParam) {
        if (versionParam === void 0) { versionParam = 'api-version'; }
        var httpc = new httpm.HttpCallbackClient(userAgent, handlers, socketTimeout);
        this.client = new RestCallbackClient(httpc, versionParam);
    }
    RestClient.prototype.get = function (requestUrl, apiVersion, additionalHeaders, serializationData) {
        return this._getJson('GET', requestUrl, apiVersion, additionalHeaders || {}, serializationData);
    };
    RestClient.prototype.del = function (requestUrl, apiVersion, additionalHeaders, serializationData) {
        return this._getJson('DELETE', requestUrl, apiVersion, additionalHeaders || {}, serializationData);
    };
    RestClient.prototype.create = function (requestUrl, apiVersion, objs, additionalHeaders, serializationData) {
        return this._sendRequest('POST', requestUrl, apiVersion, objs, additionalHeaders || {}, serializationData);
    };
    RestClient.prototype.update = function (requestUrl, apiVersion, objs, additionalHeaders, serializationData) {
        return this._sendRequest('PATCH', requestUrl, apiVersion, objs, additionalHeaders || {}, serializationData);
    };
    RestClient.prototype._getJson = function (verb, requestUrl, apiVersion, headers, serializationData) {
        var deferred = Q.defer();
        this.client._getJson(verb, requestUrl, apiVersion, headers, serializationData, function (err, statusCode, obj) {
            if (err) {
                deferred.reject(err);
            }
            else {
                var res = {};
                res.statusCode = statusCode;
                res.result = obj;
                deferred.resolve(res);
            }
        });
        return deferred.promise;
    };
    RestClient.prototype._sendRequest = function (verb, requestUrl, apiVersion, objs, headers, serializationData) {
        var deferred = Q.defer();
        this.client._sendJson(verb, requestUrl, apiVersion, objs, headers, serializationData, function (err, statusCode, obj) {
            if (err) {
                deferred.reject(err);
            }
            else {
                var res = {};
                res.statusCode = statusCode;
                res.result = obj;
                deferred.resolve(res);
            }
        });
        return deferred.promise;
    };
    return RestClient;
}());
exports.RestClient = RestClient;
var RestCallbackClient = (function () {
    function RestCallbackClient(httpClient, versionParam) {
        if (versionParam === void 0) { versionParam = 'api-version'; }
        this.httpClient = httpClient;
        this.versionParam = versionParam;
    }
    RestCallbackClient.prototype.get = function (url, apiVersion, customHeaders, serializationData, onResult) {
        this._getJson('GET', url, apiVersion, customHeaders, serializationData, onResult);
    };
    RestCallbackClient.prototype.del = function (url, apiVersion, customHeaders, serializationData, onResult) {
        this._getJson('DELETE', url, apiVersion, customHeaders, serializationData, onResult);
    };
    RestCallbackClient.prototype.create = function (url, apiVersion, resources, customHeaders, serializationData, onResult) {
        this._sendJson('POST', url, apiVersion, resources, customHeaders, serializationData, onResult);
    };
    RestCallbackClient.prototype.update = function (url, apiVersion, resources, customHeaders, serializationData, onResult) {
        this._sendJson('PATCH', url, apiVersion, resources, customHeaders, serializationData, onResult);
    };
    RestCallbackClient.prototype.options = function (url, onResult) {
        this._getJson('OPTIONS', url, "", null, null, onResult);
    };
    RestCallbackClient.prototype.uploadFile = function (verb, url, apiVersion, filePath, customHeaders, serializationData, onResult) {
        var _this = this;
        fs.stat(filePath, function (err, stats) {
            if (err) {
                onResult(err, 400, null);
                return;
            }
            var headers = customHeaders || {};
            headers["Content-Length"] = stats.size;
            var contentStream = fs.createReadStream(filePath);
            _this.uploadStream(verb, url, apiVersion, contentStream, headers, serializationData, onResult);
        });
    };
    RestCallbackClient.prototype.uploadStream = function (verb, url, apiVersion, contentStream, customHeaders, serializationData, onResult) {
        var headers = customHeaders || {};
        headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
        this.httpClient.sendStream(verb, url, contentStream, headers, function (err, res, contents) {
            if (err) {
                onResult(err, err.statusCode, contents);
                return;
            }
            _processResponse(url, res, contents, serializationData, onResult);
        });
    };
    RestCallbackClient.prototype.replace = function (url, apiVersion, resources, customHeaders, serializationData, onResult) {
        this._sendJson('PUT', url, apiVersion, resources, customHeaders, serializationData, onResult);
    };
    RestCallbackClient.prototype._getJson = function (verb, url, apiVersion, customHeaders, serializationData, onResult) {
        var headers = {};
        headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
        this.httpClient.get(verb, url, headers, function (err, res, contents) {
            if (err) {
                onResult(err, err.statusCode, null);
                return;
            }
            _processResponse(url, res, contents, serializationData, onResult);
        });
    };
    RestCallbackClient.prototype._sendJson = function (verb, url, apiVersion, resources, customHeaders, serializationData, onResult) {
        if (!resources) {
            throw new Error('invalid resource');
        }
        var headers = customHeaders || {};
        headers["Accept"] = this.createAcceptHeader('application/json', apiVersion);
        headers["Content-Type"] = headers["Content-Type"] || 'application/json; charset=utf-8';
        var data;
        if (serializationData) {
            data = serm.ContractSerializer.serialize(resources, serializationData.requestTypeMetadata, true);
        }
        data = JSON.stringify(resources, null, 2);
        this.httpClient.send(verb, url, data, headers, function (err, res, contents) {
            if (err) {
                onResult(err, err.statusCode, null);
                return;
            }
            _processResponse(url, res, contents, serializationData, onResult);
        });
    };
    RestCallbackClient.prototype.createAcceptHeader = function (type, apiVersion) {
        return type + (apiVersion ? (';' + this.versionParam + '=' + apiVersion) : '');
    };
    return RestCallbackClient;
}());
exports.RestCallbackClient = RestCallbackClient;
var httpCodes = {
    300: "Multiple Choices",
    301: "Moved Permanantly",
    302: "Resource Moved",
    304: "Not Modified",
    305: "Use Proxy",
    306: "Switch Proxy",
    307: "Temporary Redirect",
    308: "Permanent Redirect",
    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    405: "Method Not Allowed",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Timeout"
};
function _processResponse(url, res, contents, serializationData, onResult) {
    var jsonObj;
    if (contents && contents.length > 0) {
        try {
            if (serializationData) {
                jsonObj = JSON.parse(contents);
                jsonObj = serm.ContractSerializer.deserialize(jsonObj, serializationData.responseTypeMetadata, false, serializationData.responseIsCollection);
            }
            else {
                jsonObj = JSON.parse(contents);
            }
        }
        catch (e) {
            onResult(new Error('Invalid Resource'), res.statusCode, null);
            return;
        }
    }
    if (res.statusCode > 299) {
        // default error message
        var msg = httpCodes[res.statusCode] ? "Failed Request: " + httpCodes[res.statusCode] : "Failed Request";
        msg += '(' + res.statusCode + ') - ';
        // if exception/error in body, attempt to get better error
        if (jsonObj && jsonObj.message) {
            msg += jsonObj.message;
        }
        else {
            msg += url;
        }
        onResult(new Error(msg), res.statusCode, null);
    }
    else {
        onResult(null, res.statusCode, jsonObj);
    }
}
;
