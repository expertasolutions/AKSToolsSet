// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.
"use strict";
var Q = require('q');
var url = require("url");
var http = require("http");
var https = require("https");
var tunnel = require("tunnel");
http.globalAgent.maxSockets = 100;
var HttpClient = (function () {
    function HttpClient(userAgent, handlers, socketTimeout) {
        this.client = new HttpCallbackClient(userAgent, handlers, socketTimeout);
    }
    HttpClient.prototype.get = function (requestUrl, additionalHeaders) {
        return this._getRequest('GET', requestUrl, additionalHeaders || {});
    };
    HttpClient.prototype.del = function (requestUrl, additionalHeaders) {
        return this._getRequest('DELETE', requestUrl, additionalHeaders || {});
    };
    HttpClient.prototype.post = function (requestUrl, data, additionalHeaders) {
        return this._sendRequest('POST', requestUrl, data, additionalHeaders || {});
    };
    HttpClient.prototype.patch = function (requestUrl, data, additionalHeaders) {
        return this._sendRequest('PATCH', requestUrl, data, additionalHeaders || {});
    };
    HttpClient.prototype._getRequest = function (verb, requestUrl, headers) {
        var deferred = Q.defer();
        this.client.get(verb, requestUrl, headers, function (err, res, contents) {
            if (err) {
                deferred.reject(err);
            }
            else {
                var hres = {};
                hres.statusCode = res.statusCode;
                hres.contents = contents;
                deferred.resolve(hres);
            }
        });
        return deferred.promise;
    };
    HttpClient.prototype._sendRequest = function (verb, requestUrl, data, headers) {
        var deferred = Q.defer();
        this.client.send(verb, requestUrl, data, headers, function (err, res, contents) {
            if (err) {
                deferred.reject(err);
            }
            else {
                var hres = {};
                hres.statusCode = res.statusCode;
                hres.contents = contents;
                deferred.resolve(hres);
            }
        });
        return deferred.promise;
    };
    return HttpClient;
}());
exports.HttpClient = HttpClient;
var HttpCallbackClient = (function () {
    function HttpCallbackClient(userAgent, handlers, socketTimeout) {
        this.userAgent = userAgent;
        this.handlers = handlers;
        this.socketTimeout = socketTimeout ? socketTimeout : 3 * 60000;
    }
    HttpCallbackClient.prototype.get = function (verb, requestUrl, headers, onResult) {
        var options = this._getOptions(verb, requestUrl, headers);
        this.request(options.protocol, options.options, null, onResult);
    };
    // POST, PATCH, PUT
    HttpCallbackClient.prototype.send = function (verb, requestUrl, data, headers, onResult) {
        var options = this._getOptions(verb, requestUrl, headers);
        this.request(options.protocol, options.options, data, onResult);
    };
    HttpCallbackClient.prototype.sendStream = function (verb, requestUrl, stream, headers, onResult) {
        var options = this._getOptions(verb, requestUrl, headers);
        var req = options.protocol.request(options.options, function (res) {
            var output = '';
            res.on('data', function (chunk) {
                output += chunk;
            });
            res.on('end', function () {
                // res has statusCode and headers
                onResult(null, res, output);
            });
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            onResult(err, null, null);
        });
        stream.on('close', function () {
            req.end();
        });
        stream.pipe(req);
    };
    HttpCallbackClient.prototype.getStream = function (requestUrl, accept, onResult) {
        var headers = {};
        var options = this._getOptions('GET', requestUrl, headers);
        var req = options.protocol.request(options.options, function (res) {
            onResult(null, res.statusCode, res);
        });
        req.on('error', function (err) {
            onResult(err, err.statusCode, null);
        });
        req.end();
    };
    /**
     * Makes an http request delegating authentication to handlers.
     * returns http result as contents buffer
     * All other methods such as get, post, and patch ultimately call this.
     */
    HttpCallbackClient.prototype.request = function (protocol, options, data, onResult) {
        var _this = this;
        // Set up a callback to pass off 401s to an authentication handler that can deal with it
        var callback = function (err, res, contents) {
            var authHandler;
            if (_this.handlers) {
                _this.handlers.some(function (handler, index, handlers) {
                    // Find the first one that can handle the auth based on the response
                    if (handler.canHandleAuthentication(res)) {
                        authHandler = handler;
                        return true;
                    }
                    return false;
                });
            }
            if (authHandler !== undefined) {
                authHandler.handleAuthentication(_this, protocol, options, data, onResult);
            }
            else {
                // No auth handler found, call onResult normally
                onResult(err, res, contents);
            }
        };
        this.requestRaw(protocol, options, data, callback);
    };
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     */
    HttpCallbackClient.prototype.requestRaw = function (protocol, options, data, onResult) {
        var socket;
        if (data) {
            options.headers["Content-Length"] = Buffer.byteLength(data, 'utf8');
        }
        var callbackCalled = false;
        var handleResult = function (err, res, contents) {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res, contents);
            }
        };
        var req = protocol.request(options, function (res) {
            var output = '';
            res.setEncoding('utf8');
            res.on('data', function (chunk) {
                output += chunk;
            });
            res.on('end', function () {
                // res has statusCode and headers
                handleResult(null, res, output);
            });
        });
        req.on('socket', function (sock) {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this.socketTimeout, function () {
            if (socket) {
                socket.end();
            }
            handleResult(new Error('Request timeout: ' + options.path), null, null);
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err, null, null);
        });
        if (data) {
            req.write(data, 'utf8');
        }
        req.end();
    };
    HttpCallbackClient.prototype._getOptions = function (method, requestUrl, headers) {
        var parsedUrl = url.parse(requestUrl);
        var usingSsl = parsedUrl.protocol === 'https:';
        var prot = usingSsl ? https : http;
        var defaultPort = usingSsl ? 443 : 80;
        this.isSsl = usingSsl;
        var proxyUrl;
        if (process.env.HTTPS_PROXY && usingSsl) {
            proxyUrl = url.parse(process.env.HTTPS_PROXY);
        }
        else if (process.env.HTTP_PROXY) {
            proxyUrl = url.parse(process.env.HTTP_PROXY);
        }
        process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
        var options = {
            host: parsedUrl.hostname,
            port: parsedUrl.port || defaultPort,
            path: (parsedUrl.pathname || '') + (parsedUrl.search || ''),
            method: method,
            headers: headers || {}
        };
        options.headers["User-Agent"] = this.userAgent;
        var useProxy = proxyUrl && proxyUrl.hostname;
        if (useProxy) {
            var agentOptions = {
                maxSockets: http.globalAgent.maxSockets,
                proxy: {
                    // TODO: support proxy-authorization
                    //proxyAuth: "user:password",
                    host: proxyUrl.hostname,
                    port: proxyUrl.port
                }
            };
            var tunnelAgent;
            var overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            options.agent = tunnelAgent(agentOptions);
        }
        if (this.handlers) {
            this.handlers.forEach(function (handler) {
                handler.prepareRequest(options);
            });
        }
        return {
            protocol: prot,
            options: options,
        };
    };
    return HttpCallbackClient;
}());
exports.HttpCallbackClient = HttpCallbackClient;
